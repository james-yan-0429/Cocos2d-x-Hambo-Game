//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#include "LHParallaxNode.h"
#include "LHSettings.h"
#include "LHSprite.h"
////////////////////////////////////////////////////////////////////////////////

LHParallaxPointObject::LHParallaxPointObject(CCPoint _ratio)
{
	ratio = _ratio;
}

////////////////////////////////////////////////////////////////////////////////
LHParallaxNode::LHParallaxNode(CCDictionary* parallaxDict)
{
	sprites = new CCArray();
	isContinuous = parallaxDict->valueForKey("ContinuousScrolling")->boolValue();
	direction = parallaxDict->valueForKey("Direction")->intValue();
	speed = parallaxDict->valueForKey("Speed")->floatValue();
	lastPosition = CCPointMake(-100,-100);

	winSize = CCDirector::sharedDirector()->getWinSize();
	screenNumberOnTheRight = 1;
	screenNumberOnTheLeft = 0;
	screenNumberOnTheTop = 0;
	if(!isContinuous)
		speed = 1.0f;	
}
////////////////////////////////////////////////////////////////////////////////

void LHParallaxNode::addChild(LHSprite* sprite,CCPoint ratio)
{
	CCAssert( sprite != NULL, "Argument must be non-NULL");
	
	LHParallaxPointObject *obj = new LHParallaxPointObject(ratio);
	obj->ccsprite = sprite;
	obj->body = sprite->getBody();
	obj->position = sprite->getPosition();
	obj->offset = sprite->getPosition();
	obj->initialPosition = sprite->getPosition();
	sprites->addObject(obj);
	
	int scrRight = (int)(obj->initialPosition.x/winSize.width);
	
	if(screenNumberOnTheRight <= scrRight)
		screenNumberOnTheRight = scrRight+1;
		
	int scrLeft = (int)(obj->initialPosition.x/winSize.width);
    
	if(screenNumberOnTheLeft >= scrLeft)
		screenNumberOnTheLeft = scrLeft-1;

    
	int scrTop = (int)(obj->initialPosition.y/winSize.height);
	
	if(screenNumberOnTheTop <= scrTop)
		screenNumberOnTheTop = scrTop + 1;
	
	int scrBottom = (int)(obj->initialPosition.y/winSize.height);

	if(screenNumberOnTheBottom >= scrBottom)
		screenNumberOnTheBottom = scrBottom-1;
}
////////////////////////////////////////////////////////////////////////////////
CCArray* LHParallaxNode::spritesInNode()
{
	CCArray* sprs = CCArray::create();
	CCObject *obj;
	CCARRAY_FOREACH(sprites,obj)
	{
		LHParallaxPointObject* pt = (LHParallaxPointObject*)obj;
		if(pt->ccsprite != NULL)
			sprs->addObject(pt->ccsprite);
	}
	
	return sprs;
}
////////////////////////////////////////////////////////////////////////////////
CCArray* LHParallaxNode::bodiesInNode()
{
	CCArray* sprs = CCArray::create();
	CCObject *obj;
	CCARRAY_FOREACH(sprites,obj)
	{
		LHParallaxPointObject* pt = (LHParallaxPointObject*)obj;
		if(0 != pt->body)
			sprs->addObject((CCObject*)pt->body);
	}	
			 
	return sprs;
}
////////////////////////////////////////////////////////////////////////////////
void LHParallaxNode::setPosition(CCPoint pos,LHParallaxPointObject* point)
{
	if(point->ccsprite != NULL && point->body == NULL){
		point->ccsprite->setPosition(pos);
	}
	else if(point->body != NULL){
		
		float angle = point->ccsprite->getRotation();
		point->body->SetTransform(b2Vec2(pos.x/LHSettings::sharedInstance()->lhPtmRatio, 
										pos.y/LHSettings::sharedInstance()->lhPtmRatio), 
										CC_DEGREES_TO_RADIANS(-angle));
	}
}
////////////////////////////////////////////////////////////////////////////////
void LHParallaxNode::repositionPoint(LHParallaxPointObject* point)
{
	CCSize contentSize = point->ccsprite->getContentSize();
	float scaleX = point->ccsprite->getScaleX();
	float scaleY = point->ccsprite->getScaleY();
	
	switch (direction) {
		case 1: //right to left
		{
			if(point->ccsprite->getPosition().x + getContentSize().width/2.0f*scaleX <= 0)
			{
				float difX = point->ccsprite->getPosition().x + getContentSize().width/2.0f*scaleX;
		
				point->offset = ccp(winSize.width*screenNumberOnTheRight - point->ratio.x*speed -  getContentSize().width/2.0f*scaleX + difX, point->offset.y);
				
			}
		}	
			break;
			
		case 0://left to right
		{
			if(point->ccsprite->getPosition().x - getContentSize().width/2.0f*scaleX >= winSize.width)
			{
				float difX = point->ccsprite->getPosition().x - getContentSize().width/2.0f*scaleX - winSize.width;
				
				point->offset = ccp(winSize.width*screenNumberOnTheLeft + point->ratio.x*speed +  getContentSize().width/2.0f*scaleX + difX, point->offset.y);
			}
		}
			break;
			
		case 2://up to bottom
		{
			if(point->ccsprite->getPosition().y + getContentSize().height/2.0f*scaleY <= 0)
			{
				float difY = point->ccsprite->getPosition().y + getContentSize().height/2.0f*scaleY;
				
				point->offset = ccp(point->offset.x, winSize.height*screenNumberOnTheTop - point->ratio.y*speed - getContentSize().height/2.0f*scaleY + difY);
				
			}
		}
			break;
			
		case 3://bottom to top
		{
			if(point->ccsprite->getPosition().y - getContentSize().height/2.0f*scaleY >= winSize.height)
			{
				float difY = point->ccsprite->getPosition().y - getContentSize().height/2.0f*scaleY - winSize.height;
				
				point->offset = ccp(point->offset.x, winSize.height*screenNumberOnTheBottom + point->ratio.y*speed + getContentSize().height/2.0f*scaleY + difY);
				
			}
		}
			break;
		default:
			break;
	}
}
////////////////////////////////////////////////////////////////////////////////
void LHParallaxNode::visit()
{
	CCPoint pos = getPosition();
	if( ! pos.equals(lastPosition) || isContinuous) 
	{
		CCObject *obj;
		CCARRAY_FOREACH(sprites,obj)
		{
			LHParallaxPointObject *point = (LHParallaxPointObject *)obj;
			float x = pos.x * point->ratio.x + point->offset.x;
			float y = pos.y * point->ratio.y + point->offset.y;	
			
			setPosition(CCPointMake(x, y),point);	
			
			if(isContinuous)
			{
				int i = 1; //direction left to right //bottom to up
				if(direction == 1 || direction == 2) //right to left //up to bottom
					i = -1;

				repositionPoint(point);
			
				point->offset = ccp(point->offset.x + i*point->ratio.x*speed, 
									 point->offset.y + i*point->ratio.y*speed);

			}
		}
		lastPosition = pos;
	}
	CCNode::visit();
}