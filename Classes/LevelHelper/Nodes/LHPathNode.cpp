//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#include "LHPathNode.h"
#include "LevelHelper/LevelHelperLoader.h"
#include "LevelHelper/Nodes/LHSettings.h"

#include "LevelHelper/Nodes/LHSprite.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// interface CCArray (LHMutableArrayExt)
// 
// - (void)moveObjectFromIndex:(NSUInteger)from toIndex:(NSUInteger)to;
// - (CCArray *)reversedArray;
// - (void)reverse;
// end
// ////////////////////////////////////////////////////////////////////////////////
// implementation CCArray (LHMutableArrayExt)
// ////////////////////////////////////////////////////////////////////////////////
// - (void)moveObjectFromIndex:(NSUInteger)from toIndex:(NSUInteger)to
// {
//     if (to != from) {
//         id obj = [self objectAtIndex:from];
//         [obj retain];
//         [self removeObjectAtIndex:from];
//         if (to >= [self count]) {
//             [self addObject:obj];
//         } else {
//             [self insertObject:obj atIndex:to];
//         }
//         [obj release];
//     }
// }
// ////////////////////////////////////////////////////////////////////////////////
// - (CCArray *)reversedArray {
//     CCArray *array = [CCArray arrayWithCapacity:[self count]];
//     NSEnumerator *enumerator = [self reverseObjectEnumerator];
//     for (id element in enumerator) {
//         [array addObject:element];
//     }
//     return array;
// }
// ////////////////////////////////////////////////////////////////////////////////
void LHPathNode::reverse(CCArray* srcArray) 
{
    if(srcArray->count() == 0)
        return;
    
    int i = 0;
    int j = srcArray->count() - 1;
    while (i < j) {
        srcArray->exchangeObjectAtIndex(i,j);
        
        i++;
        j--;
    }
}
// end
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
LHPathNode::~LHPathNode(){		
	//NSLog("PATH NODE DEALLOC");
    
    pathPoints->release();
}
////////////////////////////////////////////////////////////////////////////////
LHPathNode::LHPathNode(CCArray *points)
{
	speed = 0.2f;
	interval = 0.01f;
	paused = false;
	startAtEndPoint = false;
	isCyclic = false;
	restartOtherEnd = false;
	axisOrientation = 0;
	
	ccsprite = NULL;
	body = NULL;
    uniqueName = NULL;
	pathPoints = new CCArray();
	pathPoints->addObjectsFromArray(points);
	
	currentPoint = 0;
	elapsed = 0.0f;
	isLine = true;
    
    pathNotifierId = NULL;
    pathNotifierSel= NULL;
	
	schedule(schedule_selector(LHPathNode::onTime));
}

void LHPathNode::onTime(float dt)
{
	elapsed = dt;
}

////////////////////////////////////////////////////////////////////////////////
float LHPathNode::rotationDegreeFromPoint(CCPoint endPoint,CCPoint startPoint)
{
	float rotateDegree = atan2(fabs(endPoint.x-startPoint.x),
							   fabs(endPoint.y-startPoint.y)) * 180.0f / M_PI;
	if (endPoint.y>=startPoint.y)
	{
		if (endPoint.x>=startPoint.x){
			rotateDegree = 180.0f + rotateDegree;
		}
		else{
			rotateDegree = 180.0f - rotateDegree;
		}
	}
	else{
		if (endPoint.x<=startPoint.x){
		}
		else{
			rotateDegree = 360.0 - rotateDegree;
		}
	}
	return rotateDegree;
}

void LHPathNode::visit()
{
	if(NULL == ccsprite)
		return;
	
	if(paused) 
		return;
	
	if(NULL == pathPoints)
		return;
                        
	CCString* ptVal = (CCString*)pathPoints->objectAtIndex(currentPoint);
	CCPoint startPosition = LHPointFromString(ptVal->getCString());
            
	int previousPoint = currentPoint -1;
	if(previousPoint < 0){
		previousPoint = 0;
	}
	
	CCString* prevVal = (CCString*)pathPoints->objectAtIndex(previousPoint);
	CCPoint prevPosition = LHPointFromString(prevVal->getCString());
	CCPoint endPosition = startPosition;
	
	float startAngle = LHPathNode::rotationDegreeFromPoint(startPosition,prevPosition);
	if(currentPoint == 0)
		startAngle = initialAngle+270;
	
	float endAngle = startAngle;
	
	if((currentPoint + 1) < (int)pathPoints->count())
	{
		CCString* val = (CCString*)pathPoints->objectAtIndex(currentPoint + 1);
		endPosition = LHPointFromString(val->getCString());                
		endAngle = LHPathNode::rotationDegreeFromPoint(endPosition,startPosition);
	}
	else {
		if(isCyclic)
		{
			if(!restartOtherEnd)
				reverse(pathPoints);
			
			currentPoint = -1;
		}
        
        if(NULL != pathNotifierId)
        {
            //pathNotifierSel(ccsprite,uniqueName);	
			
			if(!isCyclic)
                paused = true;
        }
	}
	
	if(axisOrientation == 1)
		startAngle += 90.0f;
	if(axisOrientation == 1)
		endAngle += 90.0f;
	
	if(startAngle > 360)
		startAngle -=360;
	if(endAngle > 360)
		endAngle-=360;
	
	
	float t = MIN(1, elapsed/interval);
    
	CCPoint deltaP = ccpSub( endPosition, startPosition );

	CCPoint newPos = ccp((startPosition.x + deltaP.x * t), 
						 (startPosition.y + deltaP.y * t));
            
	
	if(startAngle > 270 && startAngle < 360 &&
	   endAngle > 0 && endAngle < 90){
		startAngle -= 360;
	}
	
	if(startAngle > 0 && startAngle < 90 &&
	   endAngle < 360 && endAngle > 270){
		startAngle += 360;
	}
	
	float deltaA = endAngle - startAngle;
	float newAngle = startAngle + deltaA*t;

	if(newAngle > 360)
		newAngle -= 360;
	
	if(NULL != ccsprite)
		ccsprite->setPosition(newPos);

	if(axisOrientation != 0){
		ccsprite->setRotation(newAngle);
    }
	if(isLine){
		ccsprite->setRotation(endAngle);
    }
	
	
	float dist = ccpDistance(ccsprite->getPosition(), endPosition);
	
	if(0.001 > dist)
	{
		if(currentPoint + 1 < (int)pathPoints->count())
		{
			elapsed = 0;
			currentPoint += 1;     
		}
	}

	//updating all the shapes if any
	if(NULL != body)
	{
		if(b2_dynamicBody != body->GetType()) //we dont update dynamic bodies
		{
			if(NULL != ccsprite)
			{
				float angle = ccsprite->getRotation();
				CCPoint pos = ccsprite->getPosition();
				body->SetTransform(b2Vec2(pos.x/LHSettings::sharedInstance()->lhPtmRatio, pos.y/LHSettings::sharedInstance()->lhPtmRatio), CC_DEGREES_TO_RADIANS(-angle));
			}
		}
	}
    
	/////////////////////////////////////////
	CCNode::visit();	
}
////////////////////////////////////////////////////////////////////////////////
void LHPathNode::setUniqueName(CCString* name){
    uniqueName = name;
}
////////////////////////////////////////////////////////////////////////////////
void LHPathNode::setSprite(LHSprite* sprite)
{
    CCAssert( sprite != NULL, "Sprite must not be NULL");
    
    ccsprite = sprite;
	initialAngle = ccsprite->getRotation();
    
    ccsprite->setPathNode(this);
}

////////////////////////////////////////////////////////////////////////////////
void LHPathNode::setBody(b2Body* bd){
	body = bd;
}
////////////////////////////////////////////////////////////////////////////////
void LHPathNode::setSpeed(float value){
    
    speed = value;
    
    interval = speed/(pathPoints->count()-1);
}
////////////////////////////////////////////////////////////////////////////////
void LHPathNode::setStartAtEndPoint(bool val){
    
    startAtEndPoint = val;
    
    if(startAtEndPoint)
		reverse(pathPoints);
}

void LHPathNode::setRestartOtherEnd(bool val){

// 	startAtEndPoint = val;
// 
// 	if(startAtEndPoint)
// 		reverse(pathPoints);
}


////////////////////////////////////////////////////////////////////////////////
void LHPathNode::setPathNotifierObject(CCNode *object){
    pathNotifierId = object;
}
////////////////////////////////////////////////////////////////////////////////
void LHPathNode::setPathNotifierSelector(SEL_CallFuncND selector){
    pathNotifierSel = selector;
}
