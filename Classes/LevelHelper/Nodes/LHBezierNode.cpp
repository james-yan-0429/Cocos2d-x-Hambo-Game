//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#include "LHBezierNode.h"
#include "LevelHelper/LevelHelperLoader.h"

#include "LHPathNode.h"
#include "LHSettings.h"

//#include <Availability.h>

#ifdef __IPHONE_OS_VERSION_MAX_ALLOWED
#include <OpenGLES/EAGL.h>
#elif defined(__MAC_OS_X_VERSION_MAX_ALLOWED)
#include <OpenGL/OpenGL.h>
#endif



////////////////////////////////////////////////////////////////////////////////

LHBezierNode::~LHBezierNode()
{
	CCObject *obj;
	CCARRAY_FOREACH(pathNodes,obj)
	{
		LHPathNode* pNode = (LHPathNode*)obj;
		pNode->removeFromParentAndCleanup(true);
	}
	
	pathNodes->release();
	
	if(NULL != body)
	{
		b2World* _world = body->GetWorld();
		if(0 != _world)
		{
			_world->DestroyBody(body);
			body = NULL;
		}
	}
    
	//NSLog("BEZIER NODE DEALLOC");
	uniqueName->release();
	
	pathPoints->release();
	
	linesHolder->release();
	trianglesHolder->release();
}
////////////////////////////////////////////////////////////////////////////////
CCPoint LHBezierNode::pointOnCurve(CCPoint p1 ,CCPoint p2 ,CCPoint p3 ,CCPoint p4 ,float t)
{
	float var1, var2, var3;
    CCPoint vPoint(0.0f, 0.0f);
    
    var1 = 1 - t;
    var2 = var1 * var1 * var1;
    var3 = t * t * t;
    vPoint.x = var2*p1.x + 3*t*var1*var1*p2.x + 3*t*t*var1*p3.x + var3*p4.x;
    vPoint.y = var2*p1.y + 3*t*var1*var1*p2.y + 3*t*t*var1*p3.y + var3*p4.y;
    return(vPoint);				
}
////////////////////////////////////////////////////////////////////////////////
void LHBezierNode::initTileVerticesFromDictionary(CCDictionary* bezierDict)
{
	trianglesHolder = CCArray::create();
	
	CCPoint convert = LHSettings::sharedInstance()->convertRatio;
	CCArray* fixtures = (CCArray*)bezierDict->objectForKey("TileVertices");
	CCObject*obj;
	CCARRAY_FOREACH(fixtures,obj)
	{
		CCArray* fix = (CCArray*)obj;
		CCArray* triangle = CCArray::create();

		CCObject* strObj;
		CCARRAY_FOREACH(fix,strObj)
		{
			CCString* pt = (CCString*)strObj;
			CCPoint point = LHPointFromString(pt->getCString());
			
			point.x = point.x* convert.x;
			point.y = winSize.height - point.y*convert.y;
			
			triangle->addObject(LHStringWithCCPoint(CCPointMake(point.x, point.y)));
		}
		
		trianglesHolder->addObject(triangle);		
	}	
	
	
	linesHolder = CCArray::create();
	if(isVisible)
	{
		CCArray* curvesInShape = (CCArray*)bezierDict->objectForKey("Curves");
		
		int MAX_STEPS = 25;
		CCObject *obj;
		CCARRAY_FOREACH(curvesInShape,obj)
		{
			CCDictionary* curvDict = (CCDictionary*)obj;
			CCPoint endCtrlPt   = LHPointFromString(curvDict->valueForKey("EndControlPoint")->getCString());
			CCPoint startCtrlPt = LHPointFromString(curvDict->valueForKey("StartControlPoint")->getCString());
			CCPoint endPt       = LHPointFromString(curvDict->valueForKey("EndPoint")->getCString());
			CCPoint startPt     = LHPointFromString(curvDict->valueForKey("StartPoint")->getCString());
			
			if(!isLine)
			{
				CCPoint prevPoint;
				bool firstPt = true;
				
				for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
				{
					CCPoint vPoint = LHBezierNode::pointOnCurve(startPt,startCtrlPt,endCtrlPt,endPt,t);
					
					if(!firstPt)
					{
						CCPoint pt1 = CCPointMake(prevPoint.x*convert.x, 
												  winSize.height - prevPoint.y*convert.y);
						CCPoint pt2 = CCPointMake(vPoint.x*convert.x, 
												  winSize.height - vPoint.y*convert.y);
						
						linesHolder->addObject(LHStringWithCCPoint(CCPointMake(pt1.x, pt1.y)));
						linesHolder->addObject(LHStringWithCCPoint(CCPointMake(pt2.x, pt2.y)));
					}
					prevPoint = vPoint;
					firstPt = false;					
				}
			}
			else
			{
				
				CCPoint pos1 = CCPointMake(startPt.x*convert.x, 
										   winSize.height - startPt.y*convert.y);
				CCPoint pos2 = CCPointMake(endPt.x*convert.x, 
										   winSize.height - endPt.y*convert.y);
				
				linesHolder->addObject(LHStringWithCCPoint(CCPointMake(pos1.x, pos1.y)));
				linesHolder->addObject(LHStringWithCCPoint(CCPointMake(pos2.x, pos2.y)));
				
			}
		}
	}
}
////////////////////////////////////////////////////////////////////////////////
void LHBezierNode::initPathPointsFromDictionary(CCDictionary* bezierDict)
{
	pathPoints = CCArray::create();
	
    CCArray* curvesInShape = (CCArray*)bezierDict->objectForKey("Curves");    
    int MAX_STEPS = 25;    
	CCPoint conv = LHSettings::sharedInstance()->convertRatio;
	
	int i = 0;
	CCObject *obj;
    CCARRAY_FOREACH(curvesInShape,obj)
    {
		CCDictionary* curvDict = (CCDictionary*)obj;
        CCPoint endCtrlPt   = LHPointFromString(curvDict->valueForKey("EndControlPoint")->getCString());
        CCPoint startCtrlPt = LHPointFromString(curvDict->valueForKey("StartControlPoint")->getCString());
        CCPoint endPt       = LHPointFromString(curvDict->valueForKey("EndPoint")->getCString());
        CCPoint startPt     = LHPointFromString(curvDict->valueForKey("StartPoint")->getCString());
		
		
		if(!isLine)
        {
            for(float t = 0; t <= (1 + (1.0f / MAX_STEPS)); t += 1.0f / MAX_STEPS)
            {
				CCPoint vPoint = LHBezierNode::pointOnCurve(startPt,startCtrlPt,endCtrlPt,endPt,t);
				
                pathPoints->addObject(LHStringWithCCPoint(LHMakePoint(vPoint.x*conv.x, 
																	 winSize.height - vPoint.y*conv.y)));
            }
			
			pathPoints->removeLastObject();
        }
        else
        {
            pathPoints->addObject(LHStringWithCCPoint(LHMakePoint(startPt.x*conv.x, 
                                                    winSize.height - startPt.y*conv.y)));            
            
            if(i == curvesInShape->count()-1)
            {
                pathPoints->addObject(LHStringWithCCPoint(LHMakePoint(endPt.x*conv.x, 
                                                        winSize.height - endPt.y*conv.y))); 
            }
            ++i;
        }
	}	
	
}
////////////////////////////////////////////////////////////////////////////////
void LHBezierNode::createBodyFromDictionary(CCDictionary* bezierDict,b2World* world)
{
	if(isPath)
		return;
	
	if(pathPoints->count() < 2)
		return;
	
	b2BodyDef bodyDef;	
	
	int bodyType = bezierDict->valueForKey("PhysicType")->intValue();
	bodyDef.type = (b2BodyType)bodyType;
    
	bodyDef.position.Set(0.0f, 0.0f);
	bodyDef.angle = 0.0f;
	
	bodyDef.userData = this;
	
	body = world->CreateBody(&bodyDef);
	
    
  
	float ptm = LHSettings::sharedInstance()->lhPtmRatio;
    
	CCObject* obj;
    CCARRAY_FOREACH(trianglesHolder,obj)
    {
		CCArray* fix = (CCArray*)obj;
        int size = fix->count();
        b2Vec2 *verts = new b2Vec2[size];
        int i = 0;

		CCObject *strObj;

        CCARRAY_FOREACH(fix,strObj)
        {
			CCString* val = (CCString*)strObj;
            CCPoint pt = LHPointFromString(val->getCString());
            
            verts[i].x =pt.x/ptm;
            verts[i].y =pt.y/ptm;
            ++i;
        }

        b2PolygonShape shape;
        shape.Set(verts, size);		
        
        b2FixtureDef fixture;
        
        fixture.density = bezierDict->valueForKey("Density")->floatValue();
		fixture.friction = bezierDict->valueForKey("Friction")->floatValue();
		fixture.restitution = bezierDict->valueForKey("Restitution")->floatValue();
		
		fixture.filter.categoryBits = bezierDict->valueForKey("Category")->intValue();
		fixture.filter.maskBits = bezierDict->valueForKey("Mask")->intValue();
		fixture.filter.groupIndex = bezierDict->valueForKey("Group")->intValue();
		
		fixture.isSensor = bezierDict->valueForKey("IsSenzor")->boolValue();
        
        fixture.shape = &shape;
        body->CreateFixture(&fixture);
        delete[] verts;
    }		
    
    bool firstPoint = true;
    CCPoint prevPoint = ccp(0,0);
	CCObject* strObj;
    CCARRAY_FOREACH(pathPoints,strObj)
    {
		CCString* val = (CCString*)strObj;
        CCPoint pt = LHPointFromString(val->getCString());
        
        if(!firstPoint)
        {
            int size = 2;
            b2Vec2 *verts = new b2Vec2[size];
            
            verts[0].x =prevPoint.x/ptm;
            verts[0].y =prevPoint.y/ptm;
            verts[1].x =pt.x/ptm;
            verts[1].y =pt.y/ptm;
            
            b2EdgeShape shape;
            shape.Set(verts[0], verts[1]);
            
            b2FixtureDef fixture;
            
            fixture.density = bezierDict->valueForKey("Density")->floatValue();
            fixture.friction = bezierDict->valueForKey("Friction")->floatValue();
            fixture.restitution = bezierDict->valueForKey("Restitution")->floatValue();
            
            fixture.filter.categoryBits = bezierDict->valueForKey("Category")->intValue();
            fixture.filter.maskBits = bezierDict->valueForKey("Mask")->intValue();
            fixture.filter.groupIndex = bezierDict->valueForKey("Group")->intValue();
            
            fixture.isSensor = bezierDict->valueForKey("IsSenzor")->boolValue();
            
            fixture.shape = &shape;
            body->CreateFixture(&fixture);
            delete[] verts;
        }
        
        firstPoint = false;
        prevPoint = pt;
    }
        
}
////////////////////////////////////////////////////////////////////////////////
void LHBezierNode::initWithDictionary(CCDictionary* bezierDict ,CCLayer* ccLayer,b2World* world)
{
	isClosed	= bezierDict->valueForKey("IsClosed")->boolValue();
	isTile		= bezierDict->valueForKey("IsTile")->boolValue();
	isVisible	= bezierDict->valueForKey("IsDrawable")->boolValue();
	isLine		= bezierDict->valueForKey("IsSimpleLine")->boolValue();
	isPath		= bezierDict->valueForKey("IsPath")->boolValue();
	
	uniqueName = CCString::create(bezierDict->valueForKey("UniqueName")->getCString());
	
	pathNodes = CCArray::create();
	
	setTag(bezierDict->valueForKey("Tag")->intValue());
	setVertexZ(bezierDict->valueForKey("ZOrder")->intValue());
	
	CCString* img = CCString::create(bezierDict->valueForKey("Image")->getCString());
	imageSize = CCSizeZero;
	if(!img->m_sString.compare(""))
	{
		CCString* path = LHSettings::sharedInstance()->imagePath(img);
		texture = CCTextureCache::sharedTextureCache()->addImage(path->getCString());
		if( texture ) {
			imageSize = texture->getContentSize();
		}
	}
	
	//CCPoint convert = [[LHSettings sharedInstance] convertRatio];
	winSize = CCDirector::sharedDirector()->getWinSize();		
	
	
	color = CCRectFromString(bezierDict->valueForKey("Color")->getCString());
	lineColor = CCRectFromString(bezierDict->valueForKey("LineColor")->getCString());
	lineWidth = bezierDict->valueForKey("LineWidth")->floatValue();

	initTileVerticesFromDictionary(bezierDict);
	
	initPathPointsFromDictionary(bezierDict);	
	
	createBodyFromDictionary(bezierDict,world);

}

////////////////////////////////////////////////////////////////////////////////
void LHBezierNode::draw()
{
	/*
	if(0.0f != LHSettings::sharedInstance()->customAlpha)
	{
		glColor4f(color.origin.x, 
				  color.origin.y, 
				  color.size.width, 
				  color.size.height*LHSettings::sharedInstance()->customAlpha);
		glPushMatrix();
		
        glDisableClientState(GL_COLOR_ARRAY);
        
		glEnable(GL_TEXTURE_2D);		
		glBindTexture(GL_TEXTURE_2D, texture->getName());
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		
		CCObject *obj;
		
		CCARRAY_FOREACH(trianglesHolder,obj)
		{
			CCArray* fix = (CCArray*)obj;
			int size = fix->count();
			CCPoint* glVertices = new CCPoint[size];
			CCPoint* glUV = new CCPoint[size];
			int i = 0;

			CCObject* strObj;
			CCARRAY_FOREACH(fix,strObj)
			{
				CCString* val = (CCString*)strObj;
				CCPoint pt = LHPointFromString(val->getCString());

				glVertices[i].x =pt.x;
				glVertices[i].y =pt.y;
				
				glUV[i].x = pt.x/imageSize.width;
				glUV[i].y = (winSize.height - pt.y)/imageSize.height;
				++i;
			}
			glTexCoordPointer(2, GL_FLOAT, 0, glUV);
			glVertexPointer(2, GL_FLOAT, 0, glVertices);
			glDrawArrays(GL_TRIANGLE_FAN, 0, size);
			delete[] glVertices;
			delete[] glUV;
		}		
        
		
		float oldLineWidth = 1.0f;
		glGetFloatv(GL_LINE_WIDTH, &oldLineWidth); 
		
		glLineWidth(lineWidth);
		
		glDisable(GL_TEXTURE_2D);
		glColor4f(lineColor.origin.x, 
				  lineColor.origin.y, 
				  lineColor.size.width, 
				  lineColor.size.height*LHSettings::sharedInstance()->customAlpha);
		
		for(int i = 0; i < linesHolder->count(); i+=2)
		{
			CCPoint pt1 = LHPointFromString(((CCString*)linesHolder->objectAtIndex(i))->getCString());
			CCPoint pt2 = LHPointFromString(((CCString*)linesHolder->objectAtIndex(i+1))->getCString());
            
			CCPoint* line = new CCPoint[2];
			line[0].x = pt1.x;
			line[0].y = pt1.y;
				
			line[1].x = pt2.x;
			line[1].y = pt2.y;
			
			glVertexPointer(2, GL_FLOAT, 0, line);
			glDrawArrays(GL_LINES, 0, 2);
				
			delete[] line;
		}
        
        glEnableClientState(GL_COLOR_ARRAY);
		glLineWidth(oldLineWidth);
		glEnable(GL_TEXTURE_2D);	
		glPopMatrix();
	}*/	
}
////////////////////////////////////////////////////////////////////////////////
LHPathNode* LHBezierNode::addSpriteOnPath(LHSprite* spr,float pathSpeed ,bool startAtEndPoint,bool isCyclic,bool restartOtherEnd,int axis)
{
	LHPathNode* node = new LHPathNode(pathPoints);
	node->setSprite(spr);
	node->setBody(spr->getBody());
	node->setSpeed(pathSpeed);
    node->setStartAtEndPoint(startAtEndPoint);
    node->setRestartOtherEnd(restartOtherEnd);
	node->isCyclic = isCyclic;
	node->axisOrientation = axis;
	node->isLine = isLine;
    node->setUniqueName(uniqueName);
	pathNodes->addObject(node);
	
	getParent()->addChild(node);
    
    return  node;
}