//  This file was generated by LevelHelper
//  http://www.levelhelper.org
//
//  LevelHelperLoader.mm
//  Created by Bogdan Vladu
//  Copyright 2011 Bogdan Vladu. All rights reserved.
////////////////////////////////////////////////////////////////////////////////
//
//  This software is provided 'as-is', without any express or implied
//  warranty.  In no event will the authors be held liable for any damages
//  arising from the use of this software.
//  Permission is granted to anyone to use this software for any purpose,
//  including commercial applications, and to alter it and redistribute it
//  freely, subject to the following restrictions:
//  The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgment in the product documentation would be
//  appreciated but is not required.
//  Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
//  This notice may not be removed or altered from any source distribution.
//  By "software" the author refers to this code file and not the application 
//  that was used to generate this file.
//
////////////////////////////////////////////////////////////////////////////////
#include "LHSprite.h"
#include "LHSettings.h"
#include "LHAnimationNode.h"

#include "../LevelHelperLoader.h"
#include "Constants.h"
#include "AppDelegate.h"
#include "GameLayer/GameLayer.h"
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//-(oneway void) release{
//    
//    NSLog("LH Sprite RELEASE %", uniqueName);
//    
//    [super release];
//}
LHSprite::~LHSprite()
{		
    stopAllActions();
    removeBodyFromWorld();

    uniqueName->release();
    customUserValues->release();
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::generalLHSpriteInit(){
    body = NULL;
	uniqueName = NULL;
	customUserValues = new CCDictionary();
    
    currentFrame = 0;
    pathNode = NULL;
}
LHSprite::LHSprite()
{
	if (CCSprite::init())
    {
        generalLHSpriteInit();
    }
	afraidState = 0;
}
////////////////////////////////////////////////////////////////////////////////
LHSprite* LHSprite::spriteWithTexture(CCTexture2D* texture){
	LHSprite *spr = new LHSprite();
	spr->initWithTexture(texture);
    return spr;
}
LHSprite* LHSprite::spriteWithTexture(CCTexture2D* texture,CCRect rect){
	LHSprite *spr = new LHSprite();
	spr->initWithTexture(texture,rect);
	return spr;
}
LHSprite* LHSprite::spriteWithSpriteFrame(CCSpriteFrame*spriteFrame){
	LHSprite *spr = new LHSprite();
	spr->initWithSpriteFrame(spriteFrame);
	return spr;
}
LHSprite* LHSprite::spriteWithSpriteFrameName(CCString* spriteFrameName){
	LHSprite *spr = new LHSprite();
	spr->initWithSpriteFrameName( spriteFrameName->getCString() );
	return spr;
}
LHSprite* LHSprite::spriteWithFile(CCString* filename){
	LHSprite *spr = new LHSprite();
	spr->initWithFile( filename->getCString() );
	return spr;
}
LHSprite* LHSprite::spriteWithFile(CCString* filename,CCRect rect){
	LHSprite *spr = new LHSprite();
	spr->initWithFile( filename->getCString(),rect );
	return spr;
}
// LHSprite* LHSprite::spriteWithCGImage(CImageRef)image key:(CCString*)key{
// 	LHSprite *spr = new LHSprite();
// 	spr->sp( filename->getCString() );
// 	return spr;
//     return [[alloc] initWithCGImage:image key:key] autorelease];
// }
LHSprite* LHSprite::spriteWithBatchNode(CCSpriteBatchNode* batchNode,CCRect rect){
	LHSprite *spr = new LHSprite();
	spr->initWithTexture(batchNode->getTexture(),rect);
	return spr;
}

void LHSprite::bomb(LevelHelperLoader *level)
{
	m_level = level;
	if ( getTag() == DELETED_TAG ) return;

	//Tutorial Insert
	int *sprInd = (int*)getUserData();
	if ( sprInd )
		((GameLayer*)m_level->cocosLayer)->m_TutotialWrite.addTutorial( ((GameLayer*)m_level->cocosLayer)->m_nTick+0.06f,BODYDELETE,CCPointZero,CCPointZero,*sprInd );
	//////////////////////////////////////////////////////////////////////////

	if ( getTag() == HERO_FIRE_ARROW_BULLET || getTag() == HERO_BOMB_BULLET || getTag() == HERO_HAND_GRENADE_BULLET )
		proccessBomb(0);
	else
		schedule(schedule_selector(LHSprite::proccessBomb),0.1f);
}

#define BREAK_BOMB_RADIUS	iDevSize(90)
#define FLY_BYBOMB_RADIUS	iDevSize(107)
#define BOMB_FORCE			70

void LHSprite::proccessBomb(float dt)
{
	if((getTag() == HERO_FIRE_ARROW_BULLET) || getTag() == HERO_BOMB_BULLET	|| getTag() == HERO_HAND_GRENADE_BULLET || isBarrel(this)){
		CCArray* allEffectedObjs = CCArray::create();
		allEffectedObjs->addObjectsFromArray(m_level->spritesWithTag(ENEMY_TAG));
		allEffectedObjs->addObjectsFromArray(m_level->spritesWithTag(HERO_TAG));
		allEffectedObjs->addObjectsFromArray(m_level->spritesWithTag(DEFAULT_TAG));
		allEffectedObjs->addObjectsFromArray(m_level->spritesWithTag(ICE_TAG));

		CCObject *obj;
		CCARRAY_FOREACH( m_level->cocosLayer->getChildren(),obj )
		{
			CCNode* node = (CCNode*)obj;
			if ( node->getTag() == HERO_KNIFE_BULLET )
				allEffectedObjs->addObject(node);
		}
		

		for(int i = 0; i < (int)allEffectedObjs->count(); i++){
			LHSprite *sprObj = (LHSprite*)allEffectedObjs->objectAtIndex(i);

			//if ( sprObj->getTag() == DEFAULT_TAG && !isBarrel(sprObj) ) continue;
			
			CCPoint disPoi (sprObj->getPosition().x - getPosition().x,sprObj->getPosition().y - getPosition().y);	

			float dis = ccpDistance(CCPoint(0,0),disPoi);
			//dis -= (sprObj->getContentSize().width + sprObj->getContentSize().height) / 4;
			dis = abs(dis);

			CCRect rectBomb = CCRectMake(getPosition().x - BREAK_BOMB_RADIUS, getPosition().y - BREAK_BOMB_RADIUS, BREAK_BOMB_RADIUS * 2, BREAK_BOMB_RADIUS * 2);
			CCRect rectflybyBomb = CCRectMake(getPosition().x - FLY_BYBOMB_RADIUS, getPosition().y - FLY_BYBOMB_RADIUS, FLY_BYBOMB_RADIUS * 2, FLY_BYBOMB_RADIUS * 2);

			CCRect sprRect = sprObj->boundingBox();

			if ( isBarrel(sprObj) && rectBomb.intersectsRect(sprRect) )
			{
				sprObj->bomb(m_level);
			}
			else if (( sprObj->getTag() == DEFAULT_TAG || sprObj->getTag() == HERO_KNIFE_BULLET) && rectflybyBomb.intersectsRect(sprRect))
			{
				int nExp = 1;
				//dis = FLY_BYBOMB_RADIUS - dis;
				disPoi.x *= ( BOMB_FORCE / dis );
				disPoi.y *= ( BOMB_FORCE / dis );
				b2Vec2 F(disPoi.x*nExp,disPoi.y*nExp);
				if ( sprObj->getTag() == HERO_KNIFE_BULLET )
				{
					Bullet *b = (Bullet*)sprObj;
					b->m_body->ApplyForce(F,b->m_body->GetPosition());
					
				}
				else
					sprObj->getBody()->ApplyForce(F,sprObj->getBody()->GetPosition());
			}
			else
			{
				if( rectBomb.intersectsRect(sprRect) ){
					if ( sprObj->getTag() == HERO_TAG || sprObj->getTag() == ICE_TAG || sprObj->getTag() == ENEMY_TAG )
						sprObj->setTag(DELETED_TAG);
				}
				else if(rectflybyBomb.intersectsRect(sprRect))
				{
					int nExp = 1;
					//dis = FLY_BYBOMB_RADIUS - dis;
					disPoi.x *= ( BOMB_FORCE / dis );
					disPoi.y *= ( BOMB_FORCE / dis );
					b2Vec2 F(disPoi.x*nExp,disPoi.y*nExp);
					sprObj->getBody()->ApplyForce(F,sprObj->getBody()->GetPosition());
				}
			}
		}
		
		((AppDelegate*)CCApplication::sharedApplication())->playEff(E_BOMB);
		((GameLayer*)m_level->cocosLayer)->m_bmbManager->makeBombEffect(getPosition(),4);
		
		if ( isBarrel(this) )
			((GameLayer*)m_level->cocosLayer)->createScore( getPosition(),4000 );

		if ( getTag() == DEFAULT_TAG )
		{
			stopAllActions();
			unscheduleAllSelectors();
			removeFromParentAndCleanup(true);
			removeBodyFromWorld();
		}
		setTag(DELETED_TAG);
	}
}
////////////////////////////////////////////////////////////////////////////////
// -(id) initWithTexture:(CCTexture2D*)texture{
// 
//     self = [super initWithTexture:texture];
// 	if (self != NULL)
// 	{
// 		//generalLHSpriteInit];
// 	}
// 	return self;
// }
// -(id) initWithTexture:(CCTexture2D*)texture rect:(CCRect)rect{
// 
//     self = [super initWithTexture:texture rect:rect];
// 	if (self != NULL)
// 	{
// 		//generalLHSpriteInit];
// 	}
// 	return self;
// }
// -(id) initWithSpriteFrame:(CCSpriteFrame*)spriteFrame{
// 
//     self = [super initWithSpriteFrame:spriteFrame];
// 	if (self != NULL)
// 	{
// 		//generalLHSpriteInit];
// 	}
// 	return self;
// }
// -(id) initWithSpriteFrameName:(CCString*)spriteFrameName{
//     self = [super initWithSpriteFrameName:spriteFrameName];
// 	if (self != NULL)
// 	{
// 		//generalLHSpriteInit];
// 	}
// 	return self;    
// }
// -(id) initWithFile:(CCString*)filename{
//     self = [super initWithFile:filename];
//     if (self != NULL)
//     {
//         //generalLHSpriteInit];        
//     }
//     return self;
// }
// -(id) initWithFile:(CCString*)filename rect:(CCRect)rect{
//     self = [super initWithFile:filename rect:rect];
//     if (self != NULL)
//     {
//         //generalLHSpriteInit];
//     }
//     return self;
// }
// -(id) initWithCGImage:(CGImageRef)image key:(CCString*)key{
//     self = [super initWithCGImage:image key:key];
//     if (self != NULL)
//     {
//        // generalLHSpriteInit];
//     }
//     return self;
// }
// -(id) initWithBatchNode:(CCSpriteBatchNode*)batchNode rect:(CCRect)rect{
//     self = [super initWithBatchNode:batchNode rect:rect];
//     if (self != NULL)
//     {
//        // generalLHSpriteInit];
//     }
//     return self;
// }
// -(id) initWithBatchNode:(CCSpriteBatchNode*)batchNode rectInPixels:(CCRect)rect{
//     self = [super initWithBatchNode:batchNode rectInPixels:rect];
//     if (self != NULL)
//     {
//        // generalLHSpriteInit];
//     }
//     return self;
// }
////////////////////////////////////////////////////////////////////////////////
void LHSprite::setUniqueName(CCString* name){
    CCAssert(name!=NULL, "UniqueName must not be NULL");

    uniqueName = name;
}
CCString* LHSprite::getUniqueName()
{
    return uniqueName;   
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::setBody(b2Body* bd){
    CCAssert(bd!=NULL, "b2Body must not be NULL");
    
    body = bd;
}

b2Body* LHSprite::getBody(){
    return body;
}
bool LHSprite::removeBodyFromWorld()
{
    if(NULL != body)
	{
		b2World* _world = body->GetWorld();
		if(0 != _world)
		{
			_world->DestroyBody(body);
			body = NULL;
            
            return true;
		}
	}
    
    return false;
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::setAnimation(LHAnimationNode* anim){
    animation = anim;
    if(NULL != anim)
    {
        anim->setAnimationTexturePropertiesOnSprite(this);
        setFrame(0);
    }
}
LHAnimationNode* LHSprite::getAnimation(){
    return animation;
}
CCString* LHSprite::getAnimationName(){
    if(NULL != animation)
        return animation->getUniqueName();
    
	return CCString::create("");
}
int LHSprite::getNumberOfFrames()
{
    if(NULL != animation)
        return animation->getNumberOfFrames();
    
    return -1;
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::setFrame(int frmNo){
    
    if(animation == NULL)
        return;
    
    animation->setFrame(frmNo,this);
    currentFrame = frmNo;
}
int LHSprite::getCurrentFrame(){
    return currentFrame;
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::setPathNode(LHPathNode* node){
    CCAssert(node!=NULL, "LHPathNode must not be NULL");    
    pathNode = node;
}

LHPathNode* LHSprite::getPathNode(){
    return pathNode;
}
////////////////////////////////////////////////////////////////////////////////
void LHSprite::setCustomValue(CCObject* value,CCString* key){
    
    CCAssert(value!=NULL, "Custom value object must not be NULL");    
    CCAssert(key!=NULL, "Custom value key must not be NULL");    
    
    customUserValues->setObject(value,key->m_sString);
}
CCObject* LHSprite::getCustomValueWithKey(CCString* key){
    CCAssert(key!=NULL, "Custom value key must not be NULL");    
    return customUserValues->objectForKey(key->m_sString);

}

void LHSprite::explodeSpritesInRadius(float radius,float maxForce,CCPoint pos,b2World* world,bool doSuction)
{
	/*b2QueryCallback callback;
	b2AABB aabb;

	aabb.lowerBound = LevelHelperLoader::pointsToMeters(ccp(pos.x - radius, pos.y - radius));
	aabb.upperBound = LevelHelperLoader::pointsToMeters(ccp(pos.x + radius, pos.y + radius));

	world->QueryAABB(&callback, aabb);

	std::map<b2Body*, b2Fixture*>::iterator it;

	for(it = callback.queryInfo.begin(); it != callback.queryInfo.end(); ++it)
	{
		b2Body* b = (*it).first;    

		b2Vec2 b2TouchPosition = [LevelHelperLoader pointsToMeters:pos];
		b2Vec2 b2BodyPosition = b2Vec2(b->GetPosition().x, b->GetPosition().y);

		float maxDistance = radius/[LevelHelperLoader meterRatio];
		CGFloat distance = 0.0f;
		CGFloat strength = 0.0f;
		float force = 0.0f;
		CGFloat angle = 0.0f;

		if(doSuction) 
		{
			distance = b2Distance(b2BodyPosition, b2TouchPosition);
			if(distance > maxDistance) distance = maxDistance - 0.01;
			// Get the strength
			//strength = distance / maxDistance; // Uncomment and reverse these two. and ones further away will get more force instead of less
			strength = (maxDistance - distance) / maxDistance; // This makes it so that the closer something is - the stronger, instead of further
			force  = strength * maxForce;

			// Get the angle
			angle = atan2f(b2TouchPosition.y - b2BodyPosition.y, b2TouchPosition.x - b2BodyPosition.x);
			b->ApplyForce(b2Vec2(cosf(angle) * force, sinf(angle) * force), b->GetPosition());
		}
		else
		{
			distance = b2Distance(b2BodyPosition, b2TouchPosition);
			if(distance > maxDistance) distance = maxDistance - 0.01;

			strength = (maxDistance - distance) / maxDistance;
			force = strength * maxForce;
			angle = atan2f(b2BodyPosition.y - b2TouchPosition.y, b2BodyPosition.x - b2TouchPosition.x);
			b->ApplyForce(b2Vec2(cosf(angle) * force, sinf(angle) * force), b->GetPosition());
		}
	}*/
}